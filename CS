#!/usr/bin/env python3

import sys
import os
import re
import signal
import socket
import pickle
from random import randint

from TCP import server as TCPServer
from UDP import server as UDPServer
from UDP import client as UDPClient

users = {}
currentUser = None
currentPassword = None
pids = []

class serverTCP(TCPServer.TCPServer):
	
	def __init__(self, HOST, PORT):
		TCPServer.TCPServer.__init__(self, HOST, PORT)
		
		# self.possibleMessages has all the available commands to execute
		self.possibleMessages = {
			# AUT user pass
			'AUT': {
				'function': 'login',
				'commandReturn': 'AUR' # AUR status
			},
			# DLU
			'DLU': {
				'function': 'deleteUser',
				'commandReturn': 'DLR' # DLR status
			},
			# BCK dir N (filename date_time size)*
			# see page 6 ( f) )
			'BCK': {
				'function': 'doBackup',
				'commandReturn': 'BCK' # BKR IPBS portBS N (filename date_time size)*
			},
			# RST dir
			'RST': {
				'fucntion': 'restoreFolder',
				'commandReturn': 'RSR' # RSR IPBS portBS
			},
			# LSD
			'LSD': {
				'function': 'listDirBackedUp',
				'commandReturn': 'LDR' # LDR N (dirname)*
			},
			# LSF dir
			'LSF': {
				'function': 'listFilesBackedUpInDir',
				'commandReturn': 'LFD' # LFD BSip BSport N (filename date_time size)*
			},
			# DEL dir
			'DEL': {
				'function': 'deleteDir',
				'commandReturn': 'DDR' # DDR status
			}
		}
	
	"""
	this function will interpret the message given
	if there is no errors with the input, it will call the right function to execute with the command given
	
	in case of any error, this function will raise an IOError with the corresponding message
	"""
	def interpretMessage(self, message):
		# listMessage is a list. every position will have one word of the input
		listMessage = message.decode('UTF-8').split()
		command = listMessage[0]
		args = listMessage[1:]
		
		# if there is no errors then will execute the right fucntion
		return getattr(self, self.possibleMessages[command]['function'])(args)
	
	def existsUser(self, user):
		return user is not None
	
	def getRandomBS(self):
		fileWithBS = open("backupServers", "rb")
		backupServers = pickle.load(fileWithBS)
		
		# backupServers is not empty
		if len(backupServers) > 0:
			backupServers[randint(0, len(backupServers) - 1)]
			return backupServers[randint(0, len(backupServers) - 1)]
		else:
			raise IOError("No Backup Servers connected")
	
	def login(self, args):
		global currentUser, currentPassword, users
		
		try:
			args[0] = int(args[0])
		except ValueError:
			raise IOError("AUR ERR")
			
		if not isinstance(args, list) or len(args) != 2 or not isinstance(args[1], str):
			raise IOError("AUR ERR")
		
		user, password = args
		
		isUser = (user in users.keys())
		correctPassword = (isUser and users[user]['password'] == password)
		
		if isUser and correctPassword:
			currentUser = user
			currentPassword = password
			return "AUR OK"
		elif isUser:
			return "AUR NOK"
		else:
			users[user] = {
				'password': password,
				'dirs': {}
			}
			
			currentUser = user
			currentPassword = password
			return "AUR NEW"
	
	def deleteUser(self, args):
		
		global currentUser, users
		
		# duvida ? aqui deve enviar DLR NOK ou ERR
		# corrigir os outros identicos
		if not self.existsUser(currentUser):
			raise IOError("ERR")
		
		if users[currentUser]['dirs']:
			return "DLR NOK"
		
		users.pop(currentUser, None)
		
		return "DLR OK"
		
	
	def doBackup(self, args):
		
		global currentUser, currentPassword, users
		
		# verify all args
		lenArgs = len(args)
		if not isinstance(args, list) or lenArgs >= 2 or not isinstance(args[0], str) or not isinstance(args[1], int) or lenArgs != args[1] * 3 + 2:
			raise IOError("BKR ERR")
		
		for i in range(2, lenArgs):
			if i % 3 == 0:
				if not isinstance(args[i], str):
					raise IOError("BKR ERR")
			elif i % 3 == 1:
				try:
					day, month, year, hours, minutes, seconds = re.search('([0-9]{2})\.([0-9]{2})\.([0-9]{4}) ([0-9]{2}):([0-9]{2}):([0-9]{2})', arg[i]).groups()
				except AttributeError:
					raise IOError("BKR ERR")
			else:
				if not isinstance(args[i], int):
					raise IOError("BKR ERR")
		
		dir = args[0]
		n = args[1]
		filesToUpload = []
		# will construct what files are sent
		for i in range(2, lenArgs, 3):
			file = {}
			file['filename'] = args[i]
			file['date_time'] = args[i + 1]
			file['size'] = args[i + 2]
			filesToUpload.append(file)
		
		fileWithBS = open("backupServers", "rb")
		backupServers = pickle.load(fileWithBS)
		
		# if the given dir is not saved
		if not users[currentUser]['dirs'] or dir not in users[currentUser]['dirs'].keys() or users[currentUser]['dirs'][dir]['BS'] not in backupServers:
						
			try:
				bs = self.getRandomBS()
			except IOError:
				raise IOError("BKR EOF")
					
			client_UDP = clientUDP(bs)
			reply = client_UDP.registerUserToBS(currentUser, currentPassword)			
			if reply == 'OK':
				users[currentUser]['dirs'][dir] = {'BS': bs}
		
		else:
			bs = users[currentUser]['dirs'][dir]['BS']
			client_UDP = clientUDP(bs)
			receivedMessage = client_UDP.listFiles(currentUser, currentPassword)
			words = receivedMessage.split()
			for i in range(0, len(words), 3):
				file = {}
				file['filename'] = args[i]
				file['date_time'] = args[i + 1]
				file['size'] = args[i + 2]
				if file in filesToUpload:
					filesToUpload.remove(file)
		
		stringToReturn = "BKR " + users[currentUser]['dirs']['BS']['IPBS'] + " " + users[currentUser]['dirs']['BS']['portBS'] + len(filesToUpload)
		for file in filesToUpload:
			stringToReturn += " " + str(file['filename']) + " " + str(file['date_time']) + " " + str(file['size'])
		
		return stringToReturn
		
		
	def listDirBackedUp(self, args):
		global currentUser, users
		
		if len(args) != 0:
			raise IOError("LSD ERR")
		
		strToReturn = "LDR " + str(len(users[currentUser]['dirs'].keys()))
		
		fileWithBS = open("backupServers", "rb")
		backupServers = pickle.load(fileWithBS)
		
		for dir in users[currentUser]['dirs'].keys():
			if users[currentUser]['dirs'][dir]['BS'] in backupServers:
				strToReturn += " " + dir
		
		return strToReturn
	
	def listFilesBackedUpInDir(self, args):
		global users, currentUser
		
		if len(args) != 1 and not isinstance(args[0], str):
			raise IOError("LSF ERR")
		
		# duvida ? tem que fazer login antes de pedir para listar
		
		fileWithBS = open("backupServers", "rb")
		backupServers = pickle.load(fileWithBS)
		
		if args[0] not in users[currentUser]['dirs']:
			return "LFD NOK"
		
		bs = users[currentUser]['dirs'][args[0]]['BS']
		
		# we cannot retrieve the files because there is no BS where the dir was saved
		if bs not in backupServers:
			raise IOError("LFD NOK")
		
		client_UDP = clientUDP(bs)
		files = client_UDP.listFiles(currentUser, args[0])
		
		strToReturn = "LFD " + str(bs['IPBS']) + " " + str(bs['portBS']) + " " + str(len(files))
		
		for file in files:
			strToReturn += " " + str(file['filename']) + " " + str(file['date_time']) + " " + str(file['size'])
		
		return strToReturn
	
	# DEL dir
	#'DEL': {
	#	'function': 'deleteDir',
	#	'commandReturn': 'DDR' # DDR status
	#}	
	

class serverUDP(UDPServer.UDPServer):
	
	def __init__(self, HOST, PORT):
		UDPServer.UDPServer.__init__(self, HOST, PORT)
		
		# self.possibleMessages has all the available commands to execute
		self.possibleMessages = {
			# REG IPBS portBS
			'REG': {
				'function': 'registerBS',
				'commandReturn': 'RGR' # RGR status
			},
			# UNR IPBS portBS
			'UNR': {
				'function': 'unregisterBS',
				'commandReturn': 'UAR' # UAR status
			}
		}
		
	
	"""
	this function will interpret the message given
	if there is no errors with the input, it will call the right function to execute with the command given
	
	in case of any error, this function will raise an IOError with the corresponding message
	"""
	def interpretMessage(self, message):
		# listMessage is a list. every position will have one word of the input
		listMessage = message.decode('UTF-8').split()
		command = listMessage[0]
		args = listMessage[1:]
		
		# if there is no errors then will execute the right fucntion
		return getattr(self, self.possibleMessages[command]['function'])(args)
		
	def registerBS(self, args):		
		try:
			args[1] = int(args[1])
		except ValueError:
			raise IOError("RGR ERR")
		
		if len(args) != 2 or not isinstance(args[0], str):
			raise IOError("RGR ERR")
		
		fileWithBS = open("backupServers", "rb")
		backupServers = pickle.load(fileWithBS)
		
		bs = {'IPBS': args[0], 'portBS': args[1]}
		if bs not in backupServers:
			backupServers.append(bs)
			fileWithBS = open("backupServers", "wb")
			pickle.dump(backupServers, fileWithBS, protocol=pickle.HIGHEST_PROTOCOL)
			fileWithBS.close()
			return "RGR OK"
		else:
			return "RGR NOK"
	
	def unregisterBS(self, args):		
		try:
			args[1] = int(args[1])
		except ValueError:
			raise IOError("UAR ERR")
		
		if len(args) != 2 or not isinstance(args[0], str):
			raise IOError("UAR ERR")
		
		fileWithBS = open("backupServers", "rb")
		backupServers = pickle.load(fileWithBS)
		
		bs = {'IPBS': args[0], 'portBS': args[1]}
		if bs in backupServers:
			backupServers.remove(bs)
			fileWithBS = open("backupServers", "wb")
			pickle.dump(backupServers, fileWithBS, protocol=pickle.HIGHEST_PROTOCOL)
			fileWithBS.close()
			return "UAR OK"
		else:
			return "UAR NOK"

			
class clientUDP(UDPClient.UDPClient):
	
	def __init__(self, UDP_HOST, UDP_PORT):
		UDPClient.__init__(self, UDP_HOST, UDP_PORT)
		
		# self.possibleMessages has all the available commands to execute
		self.possibleMessages = {
			# LSF user dir
			'LSF': {
				'function': 'listFiles',
				'commandReturn': 'LFD' # LFD N (filename date_time size)*
			},
			# LSU user pass
			'LSU': {
				'function': 'registerUserToBS',
				'commandReturn': 'LUR' # LUR status
			},
			# DLB user dir
			'DLB': {
				'function': 'deleteDir',
				'commandReturn': 'DBR' # DBR status
			}
		}
	
	def listFiles(self, user, dir):
		
		try:
			user = int(user)
		except ValueError:
			raise IOError("LSF ERR")
		
		if not isinstance(dir, str):
			raise IOError("LSF ERR")
		
		reply = sendMessage('LSF ' + user + ' ' + dir)			
		reply = reply.split()
		
		try:
			reply[1] = int(reply[1])
		except ValueError:
			raise IOError("LFD ERR")
		
		if reply[0] == 'LFD' and (len(reply) - 2) % 3 == 0 and (len(reply) - 2) / 3 == reply[1]:
			files = []
			for i in range(2, reply[1] + 2, 3):
				file = {}
				file['filename'] = reply[i]
				file['date_time'] = reply[i + 1]
				file['size'] = reply[i + 2]
				files.append(file)
			return files
		else:
			raise IOError("LFD ERR")			
	
	def registerUserToBS(self, user, password):
		try:
			user = int(user)
		except ValueError:
			raise IOError("LSU ERR")
		
		if not isinstance(password, str):
			raise IOError("LSU ERR")
		
		reply = self.sendMessage('LSU ' + user + ' ' + password)
		
		reply = reply.split()
		if len(reply) == 2 and reply[0] == 'LUR' and ('OK' in reply[1] or 'NOK' in reply[1]):
			return reply[1]
		else:
			raise IOError("LSU ERR")
	
	def deleteDir(self, user, dir):
		try:
			user = int(user)
		except ValueError:
			raise IOError("DLB ERR")
		
		if not isinstance(dir, str):
			raise IOError("DLB ERR")
		
		reply = self.sendMessage('DLB ' + user + ' ' + dir)
		
		reply = reply.split()
		if len(reply) == 2 and reply[0] == 'DBR' and ('OK' in reply[1] or 'NOK' in reply[1]):
			return reply[1]
		else:
			raise IOError("DLB ERR")
			
			
			
			
			
def pidExists(pid):
	try:
		os.kill(pid, 0)
	except OSError:
		# if it raises OSError, there is no process with the given pid
		return False
	
	return True
			
def serverErrorHandle():
	global pids
	
	myPID = os.getpid()
	for pid in pids:
		if pid != myPID and pidExists(pid):
			os.kill(pid, signal.SIGTERM)
	
	if pids[0] == myPID:
		print("\nThanks for using this CS")

def sigterm_handler(_signo, _stack_frame):
	serverErrorHandle()
	sys.exit(0)
		
if __name__ == "__main__":
	
	PORT = 58004
	HOST = socket.gethostbyname(socket.gethostname())
	# read all arguments (it only matters the "-p" argument)
	lenArgv = len(sys.argv)
	for index in range(0, lenArgv):
		if (sys.argv[index] == "-p"):
			index += 1
			PORT = int(sys.argv[index])
	
	print("CS is running at " + str(HOST) + ":" + str(PORT))
	
	fileWithBS = open("backupServers", "wb")
	pickle.dump([], fileWithBS, protocol=pickle.HIGHEST_PROTOCOL)
	fileWithBS.close()
	
	pids.append(os.getpid())
	pidUDPServer = os.fork()
	if pidUDPServer == 0:
		pids.append(os.getpid())
		
		#this will be the child process
		try:
			server_UDP = serverUDP(HOST, PORT)
			while True:
				server_UDP.run()
		except IOError as error:
			print(error)
			serverErrorHandle()
			sys.exit(1)
		except Exception:
			print("Something went wrong. Please restart the Central Server")
			serverErrorHandle()
			sys.exit(1)
			
	elif pidUDPServer != -1:
		# this will be the parent process
		pids.append(pidUDPServer)
		
		# for Ctrl+c command
		signal.signal(signal.SIGINT, sigterm_handler)
		# for kill command
		signal.signal(signal.SIGTERM, sigterm_handler)
		
		try:
			server_TCP = serverTCP(HOST, PORT)
			while True:
				server_TCP.establishConnection()
				server_TCP.run()
		except IOError as error:
			print(error)
			serverErrorHandle()
			sys.exit(1)
		except Exception as msg:
			print(msg)
			print("Something went wrong. Please restart the Central Server")
			serverErrorHandle()
			sys.exit(1)
			
	else:
		print("No fork was made. Please try restart the Central Server")
		serverErrorHandle()
		sys.exit(1)
			