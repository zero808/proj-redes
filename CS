#!/usr/bin/env python3

import sys
import re
import signal
from TCP import server as TCPServer
from UDP import server as UDPServer
from UDP import client as UDPClient

users = {}
currentUser = None
currentPassword = None
backupServers = {}

class serverTCP(TCPServer.TCPServer):
	
	def __init__(self, PORT):
		TCPServer.TCPServer.__init__(self, PORT)
		
		# self.possibleMessages has all the available commands to execute
		self.possibleMessages = {
			# AUT user pass
			'AUT': {
				'function': 'login',
				'commandReturn': 'AUR' # AUR status
			},
			# DLU
			'DLU': {
				'function': 'deleteUser',
				'commandReturn': 'DLR' # DLR status
			},
			# BCK dir N (filename date_time size)*
			# see page 6 ( f) )
			'BCK': {
				'function': 'doBackup',
				'commandReturn': 'BCK' # BKR IPBS portBS N (filename date_time size)*
			},
			# RST dir
			'RST': {
				'fucntion': 'restoreFolder',
				'commandReturn': 'RSR' # RSR IPBS portBS
			},
			# LSD
			'LSD': {
				'function': 'listDirBackedUp',
				'commandReturn': 'LDR' # LDR N (dirname)*
			},
			# LSF dir
			'LSF': {
				'function': 'listFilesBackedUpInDir',
				'commandReturn': 'LFD' # LFD BSip BSport N (filename date_time size)*
			},
			# DEL dir
			'DEL': {
				'function': 'deleteDir',
				'commandReturn': 'DDR' # DDR status
			}
		}
	
	"""
	this function will interpret the message given
	if there is no errors with the input, it will call the right function to execute with the command given
	
	in case of any error, this function will raise an IOError with the corresponding message
	"""
	def interpretMessage(self, message):
		# listMessage is a list. every position will have one word of the input
		listMessage = message.decode('UTF-8').split()
		command = listMessage[0]
		args = listMessage[1:]
		
		# if there is no errors then will execute the right fucntion
		return getattr(self, self.possibleMessages[command]['function'])(args)
	
	def existsUser(self, user):
		return user is not None
	
	def getRandomBS(self):
		return 1
	
	def login(self, args):
		global currentUser, currentPassword, users
		
		try:
			int(args[0])
		except ValueError:
			raise IOError("AUR ERR")
			
		if not isinstance(args, list) or len(args) != 2 or not isinstance(args[1], str):
			raise IOError("AUR ERR")
		
		user, password = args
		
		isUser = (user in users.keys())
		correctPassword = (isUser and users[user]['password'] == password)
		
		if isUser and correctPassword:
			currentUser = user
			currentPassword = password
			return "AUR OK"
		elif isUser:
			return "AUR NOK"
		else:
			users[user] = {'password': password}
			users[user]['dirs'] = {}
			currentUser = user
			currentPassword = password
			return "AUR NEW"
	
	def deleteUser(self, args):
		
		global currentUser, users
		
		if not self.existsUser(currentUser):
			raise IOError("ERR")
		
		if users[currentUser]['dirs']:
			return "DLR NOK"
		
		users.pop(currentUser, None)
		
		return "DLR OK"
		
	
	def doBackup(self, args):
		
		global currentUser, currentPassword, users
		
		# verify all args
		lenArgs = len(args)
		if not isinstance(args, list) or lenArgs >= 2 or not isinstance(args[0], str) or not isinstance(args[1], int) or lenArgs != args[1] * 3 + 2:
			raise IOError("BKR ERR")
		
		for i in range(2, lenArgs):
			if i % 3 == 0:
				if not isinstance(args[i], str):
					raise IOError("BKR ERR")
			elif i % 3 == 1:
				try:
					day, month, year, hours, minutes, seconds = re.search('([0-9]{2})\.([0-9]{2})\.([0-9]{4}) ([0-9]{2}):([0-9]{2}):([0-9]{2})', arg[i]).groups()
				except AttributeError:
					raise IOError("BKR ERR")
			else:
				if not isinstance(args[i], int):
					raise IOError("BKR ERR")
		
		dir = args[0]
		n = args[1]
		filesToUpload = []
		# will construct what files are sent
		for i in range(2, lenArgs, 3):
			file = {}
			file['filename'] = args[i]
			file['date_time'] = args[i + 1]
			file['size'] = args[i + 2]
			filesToUpload.append(file)
		
		# it means that this dictionary is empty
		if not users[currentUser]['dirs'] or dir not in users[currentUser]['dirs'].keys():
			
			if not users[currentUser]['dirs']:
				users[currentUser]['dirs'] = {}
			
			i = 0
			while i < 3:
				# will create a new user in a random BS
				ipBS, portBS = getRandomBS()
				# it will try 5 times to contact the BS that was chosen
				j = 0
				while j < 5:
					client_UDP = clientUDP(bs['IP'], bs['PORT'])
					reply = client_UDP.registerUserToBS(currentUser, currentPassword)			
					if reply == 'OK':
						users[currentUser]['dirs'][dir] = {'BS': {'IP': ipBS, 'PORT': portBS}}
						break
					j += 1
				
				# it means that was successful in the process of register the user to a BS
				if j < 5:
					break
				
				i += 1
			
			if i >= 3:
				print("ERR")
				sys.exit(1)
		
		else:
			bs = users[currentUser]['dirs'][dir]['BS']
			client_UDP = clientUDP(bs['IP'], bs['PORT'])
			receivedMessage = client_UDP.listFiles(currentUser, currentPassword)
			words = receivedMessage.split()
			for i in range(0, len(words), 3):
				file = {}
				file['filename'] = args[i]
				file['date_time'] = args[i + 1]
				file['size'] = args[i + 2]
				if file in filesToUpload:
					filesToUpload.remove(file)
		
		stringToReturn = "BKR " + users[currentUser]['dirs']['BS']['IP'] + " " + users[currentUser]['dirs']['BS']['PORT'] + len(filesToUpload) + " "
		for file in filesToUpload:
			stringToReturn += "(" + file['filename'] + " " + file['date_time'] + " " + file['size'] + ") "
		
		return stringToReturn[:-1]

class serverUDP(UDPServer.UDPServer):
	
	def __init__(self, PORT):
		UDPServer.UDPServer.__init__(self, PORT)
		
		# self.possibleMessages has all the available commands to execute
		self.possibleMessages = {
			# REG IPBS portBS
			'REG': {
				'function': 'registerBS',
				'commandReturn': 'RGR' # RGR status
			},
			# UNR IPBS portBS
			'UNR': {
				'function': 'unregisterBS',
				'commandReturn': 'UAR' # UAR status
			}
		}
		
	
	"""
	this function will interpret the message given
	if there is no errors with the input, it will call the right function to execute with the command given
	
	in case of any error, this function will raise an IOError with the corresponding message
	"""
	def interpretMessage(self, message):
		# listMessage is a list. every position will have one word of the input
		listMessage = message.decode('UTF-8').split()
		command = listMessage[0]
		args = listMessage[1:]
		
		if command in self.possibleMessages.keys():
			possibleArgs = self.possibleMessages[command]['arguments']
		else:
			raise IOError("ERR")
		
		# if there is no errors then will execute the right fucntion
		return getattr(self, self.possibleMessages[command]['function'])(args)
		
	def registerBS(self, args):
		
		if len(args) != 2 or not isinstance(args[0], str) or not isinstance(args[1], int):
			raise IOError("REG ERR")
		
		bs = {'IPBS': args[0], 'portBS': args[1]}
		if bs not in backupServers:
			backupServers.append(bs)
			return "RGR OK"
		else:
			return "RGR NOK"
	
	def unregisterBS(self, args):
		
		if len(args) != 2 or not isinstance(args[0], str) or not isinstance(args[1], int):
			raise IOError("UAR ERR")
		
		bs = {'IPBS': args[0], 'portBS': args[1]}
		if bs in backupServers:
			backupServers.remove(bs)
			return "UAR OK"
		else:
			return "UAR NOK"

			
class clientUDP(UDPClient.UDPClient):
	
	def __init__(self, UDP_HOST, UDP_PORT):
		UDPClient.__init__(self, UDP_HOST, UDP_PORT)
		
		# self.possibleMessages has all the available commands to execute
		self.possibleMessages = {
			# LSF user dir
			'LSF': {
				'function': 'listFiles',
				'commandReturn': 'LFD' # LFD N (filename date_time size)*
			},
			# LSU user pass
			'LSU': {
				'function': 'registerUserToBS',
				'commandReturn': 'LUR' # LUR status
			},
			# DLB user dir
			'DLB': {
				'function': 'deleteDir',
				'commandReturn': 'DBR' # DBR status
			}
		}
	
	def listFiles(self, user, dir):
		if not isinstance(user, int) or not isinstance(dir, str):
			print("ERR")
			sys.exit(1)
		
		reply = sendMessage('LSF ' + user + ' ' + dir)
		if 'ERR' in reply:
			print("ERR")
			sys.exit(1)
			
		reply = reply.split()
		if reply[0] == 'LFD' and isinstance(reply[1], int) and (len(reply) - 2) % 3 == 0:
			return reply[2:]
		else:
			print("ERR")
			sys.exit(1)			
	
	def registerUserToBS(self, user, password):
		if not isinstance(user, int) or not isinstance(password, str):
			print("ERR")
			sys.exit(1)
		
		reply = sendMessage('LSU ' + user + ' ' + password)
		if 'ERR' in reply:
			print("ERR")
			sys.exit(1)
		
		reply = reply.split()
		if len(reply) == 2 and reply[0] == 'LUR' and ('OK' in reply[1] or 'NOK' in reply[1]):
			return reply[1]
		else:
			print("ERR")
			sys.exit(1)
	
	def deleteDir(self, user, dir):
		if not isinstance(user, int) or not isinstance(dir, str):
			print("ERR")
			sys.exit(1)
		
		reply = sendMessage('DLB ' + user + ' ' + dir)
		if 'ERR' in reply:
			print("ERR")
			sys.exit(1)
		
		reply = reply.split()
		if len(reply) == 2 and reply[0] == 'DBR' and ('OK' in reply[1] or 'NOK' in reply[1]):
			return reply[1]
		else:
			print("ERR")
			sys.exit(1)
			
			
			
			
			
			
			
			

def sigterm_handler(_signo, _stack_frame):
	# Raises SystemExit(0):
	sys.exit(0)
		
if __name__ == "__main__":
	
	# for Ctrl+c command
	signal.signal(signal.SIGINT, sigterm_handler)
	# for kill command
	signal.signal(signal.SIGTERM, sigterm_handler)
	
	PORT = 58004
	
	# read all arguments (it only matters the "-p" argument)
	lenArgv = len(sys.argv)
	for index in range(0, lenArgv):
		if (sys.argv[index] == "-p"):
			index += 1
			PORT = int(sys.argv[index])
	
	server_TCP = serverTCP(PORT)
	server_UDP = serverUDP(PORT)
	try:
		while True:
			server_TCP.establishConnection()
			server_TCP.run()
			#server_UDP.run()
	except (IOError, RuntimeError) as exception:
		print(exception)
	finally:
		print("\nThanks for using this CS")
			
		
