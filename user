#!/usr/bin/env python3
#vim: set filetype=python

import sys
import socket

# Auxiliary functions

def initialParams():
    import argparse
    "Sets up the initial Central Server ip and port"
    parser = argparse.ArgumentParser(sys.argv[1:])
    parser.add_argument('-n', help='Central Server name', default='localhost')
    parser.add_argument('-p', help='Central Server port', default='58004')
    args = parser.parse_args()
    return args

def readCommand():
    try:
        listAvailableCommands()
        command = input("$ ")
        tokens = command.split(' ')
        if len(tokens) > 0 and isValidCommand(tokens[0]):
            #pass every token
            executeCommand(tokens)

    except EOFError:
        pass

def isValidCommand(command = ""):
    return command in valid.keys()

def executeCommand(command):
    """Execute the command based on the command supplied as input and pass
    the remaining arguments.
    Each command decides how to manage the several tokens"""
    valid.get(command[0])(command)

def makeProtocolString(*command):
    ret =  ' '.join(command)
    return ret + '\n'

def printDirContent(arg, dirname):
    pass

def getDirContent(dir):
    pass

def isLoggedIn():
    return user != "" and password != ""

def listAvailableCommands():
    "Lists the available commands to the user in Standard Output"
    print("", "Available Commands:", sep="\n")
    if isLoggedIn():
        print("deluser",
                "backup dir",
                "restore dir",
                "dirlist",
                "filelist dir",
                "delete dir",
                "logout",
                sep="\n")
    else:
        print("login user pass")
    print("exit")

def call(socket, message ):
    buffer_size = 4096
    chunks = []
    bytes_rec = 0
    ret = NOK

    #Send our request (after converting it to bytes)
    socket.sendall(str.encode(message))

    #keep reading the response
    while bytes_rec < buffer_size:
        data = socket.recv(buffer_size)
        #the server closed the connection, i.e., there is
        #no more data to be received
        if data == b'':
            break
        #print(data.decode())

        chunks.append(data)
        bytes_rec = bytes_rec + len(data)
        # we got the final '\n' so this was the last message
        if data.endswith(b'\n'):
            break

    ret = b''.join(chunks).strip()

    print(ret)
    return ret

def loginAux(socket):
    message = makeProtocolString("AUT", user, password)
    return call(socket, message)

############################################
# User API

def login(args):
    "Login with user and pass"
    #user, password
    if not isLoggedIn() and len(args) == 3:
        global user
        user = args[1]
        global password
        password = args[2]

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect(CS)
            #perform service call
            status = loginAux(s)
            if status == OK:
                pass
            elif status == NOK:
                #clean up
                logout(None)
            elif status == NEW:
                pass
            return status
    except ConnectionRefusedError:
        print("Error in connecting to socket on port: ", CS[1])

def deluser(args):
    "Deletes this user from the server"
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect(CS)
            if loginAux(s) == OK:
                ret = call(s, makeProtocolString("DLU"))
                if ret == OK:
                    logout(None)
                elif ret == NOK:
                    print("Error: Could not delete the current user")
            else:
                print("Error: Could not delete the current user")
    except ConnectionRefusedError:
        print("Error in connecting to socket on port: ", CS[1])

def backup(args):
    "Performs a backup of directory dir"
    pass

def restore(args):
    "Restores the directory dir"
    pass

def dirlist(args):
    "Lists all the directories"
    pass

def filelist(args):
    "Lists all the files in the directory dir"
    pass

def delete(args):
    "Deletes directory dir"
    pass

def logout(args):
    "Logs out the current logged user"
    #maybe have a variable with the current user since we need to perform
    #a login with EVERY COMMAND
    global user
    user = ""
    global password
    password = ""

def exit(args):
    "Exits the application"
    #Perform any clean up necessary
    global keepGoing
    keepGoing = False
    print("exit")


############################################
# Global variables
###########################################
#Return codes
OK = "OK"
NOK = "NOK"
NEW = "NEW"

# valid commands and their respective implementation
valid = { "login": login,
        "deluser": deluser,
        "backup": backup,
        "restore": restore,
        "dirlist": dirlist,
        "filelist": filelist,
        "delete": delete,
        "logout": logout,
        "exit": exit }

# Entry Point
keepGoing = True

# User and password
user = ""
password = ""

# Central Server location
CS = ()
# Backup Server location
#BS = ()
############################################

def main():
    u = initialParams() #access u.n and u.p
    global CS
    CS = (socket.gethostbyname(u.n), int(u.p))

    while keepGoing:
        readCommand()


if __name__ == "__main__":
    main()
